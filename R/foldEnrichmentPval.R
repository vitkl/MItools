##' Find pvalue for each protein-feature pair in the network
##' @name foldEnrichmentPval
##' @name plotFoldEnrichmentDist
##' @description \code{foldEnrichmentPval} calculates how often each fold Enrichment value for the protein-feature pair is as high or higher than the foldEnrichment value for the protein - any (random) feature pairs (obtained from permutations using \code{\link[MItools]{foldEnrichmentDist}}).
##' @description \code{plotFoldEnrichmentDist} allows to visualise sampled fold Enrichment distribution and the real fold Enrichment for the protein-feature pair for specific protein
##' @param fold_enrichment_dist data.table containing fold enrichment for each domain (or other feature) - protein pair (2 columns: IDs_interactor_viral and sampled_fold_enrichment), generated by \code{\link[MItools]{foldEnrichmentDist}}
##' @param data data.table containing foldEnrichment value for each protein-feature pair (4 columns: IDs_interactor_viral, IDs_interactor_human, IDs_domain_human, fold_enrichment)
##' @param cores specify how many cores to use for parallel processing, default (NULL) is to detect all cores on the machine and use all minus one. When using LSF cluster you must specify the number of cores to use because \code{\link[BiocGenerics]{detectCores}} doen't know how much cores you have requested from LSF (with bsub -n) and detects all cores on the actual physical node.
##' @param proteinID character specifying proteinID for which to plot fold Enrichment distribution
##' @return data.table containing pvalue for each protein-feature pair for each protein-feature pair in the network (4 columns: proteinID, IDs_interactor_human, featureID, foldEnrichment and Pval)
##' @usage foldEnrichmentPval(fold_enrichment_dist, data, cores = NULL)
##' plotFoldEnrichmentDist(proteinID, fold_enrichment_dist, data)
##' @author Vitalii Kleshchevnikov
##' @import data.table
##' @import BiocGenerics
##' @export foldEnrichmentPval
##' @export plotFoldEnrichmentDist
foldEnrichmentPval = function(fold_enrichment_dist, data, cores = NULL){
  # subset data
  data = unique(data[,.(IDs_interactor_viral, IDs_domain_human, fold_enrichment)])
  # split huge foldEnrichment distribution data.table into list of data.tables, one per viral protein ID
  split_fold_enrichment_dist = split(fold_enrichment_dist, fold_enrichment_dist$IDs_interactor_viral)

  # set up parallel processing
  # create cluster
  if(is.null(cores)) cores = detectCores()-1
  cl <- makeCluster(cores)
  # get library support needed to run the code
  clusterEvalQ(cl, {library(data.table); library(MItools)})

  # loop over each viral protein and calculate the fraction of sampled_fold_enrichment that is higher or equal to fold_enrichment, write into Pval column and select only necessary columns for minimal representation
  pval_list = parLapply(cl, split_fold_enrichment_dist[1:3], function(one_fold_enrichment_dist, data){
    merged = one_fold_enrichment_dist[data, nomatch = 0, on = "IDs_interactor_viral", allow.cartesian = T]
    merged[, Pval := mean(fold_enrichment >= sampled_fold_enrichment), by = IDs_domain_human]
    #unique(merged[,.(IDs_interactor_viral, IDs_domain_human, fold_enrichment, Pval)])
  }, data)

  # stop the cluster
  stopCluster(cl)

  # convert per viral protein list to data.table
  pval_table = Reduce(rbind, pval_list)

}

plotFoldEnrichmentDist = function(proteinID, fold_enrichment_dist, data){
  one_fold_enrichment_dist = fold_enrichment_dist[IDs_interactor_viral == proteinID,]
  merged = one_fold_enrichment_dist[data, nomatch = 0, on = "IDs_interactor_viral", allow.cartesian = T]
  hist_merged = hist(merged[,sampled_fold_enrichment], main = paste0("fold enrichment distribution (sampled, from permutations) \n UniProtKB-AC: ", proteinID), xlab ="fold enrichment")
  abline(v = merged[,fold_enrichment], col = "red")
  text(x = merged[,fold_enrichment], y = mean(hist_merged$counts), labels = merged[,IDs_domain_human])
}
