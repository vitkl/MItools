##' Benchmark linear motif instance found using QSLIMFinder (SLIMFinder)
##' @rdname benchmarkMotifs
##' @name benchmarkMotifs
##' @author Vitalii Kleshchevnikov
##' @param occurence_file a path to a tsv (txt) file containing QSLIMFinder (SLIMFinder) occurence output
##' @param main_file a path to a tsv (txt) file containing QSLIMFinder (SLIMFinder) main output
##' @param domain_res RData containing objects generated by what_we_find_VS_ELM.Rmd script (specifically res_count object)
##' @param motif_setup
##' @param domain_results_obj character, name of the object containing domain enrichment results (class == XYZinteration_XZEmpiricalPval)
##' @param motif_input_obj character, name of the object of class InteractionSubsetFASTA_list containing: FASTA sequences for interacting proteins, molecular interaction data they correspond to. Each element of a list contains input for individual QSLIMFinder run.
##' @param one_from_cloud
##' @param type
##' @param dbfile_main
##' @param dburl_main
##' @param dbfile_query
##' @param dburl_query
##' @param query_res_query_only
##' @param motif_types
##' @param seed
##' @param N
##' @param replace
##' @param within1sequence
##' @param predictor_col
##' @param normalise
##' @param minoverlap integer, passed to \code{\link[GenomicRanges]{findOverlaps}}
##' @param maxgap integer, passed to \code{\link[GenomicRanges]{findOverlaps}}
##' @param ... other arguments passed to passed to \code{\link[GenomicRanges]{findOverlaps}}
##' @return object class \code{benchmarkMotifsResult) containing occurence (GRanges), instances_all (GRanges, known instances in all proteins or all excluding the query proteins), instances_query (GRanges, known instances in query proteins), predictions_all (for ROCR), labels_all (for ROCR), predictions_query (for ROCR), labels_query (for ROCR), overlapping_GRanges_all (GRanges, known instances that we also found), overlapping_GRanges_query(GRanges, known instances that we also found), N_query_prot_with_known_instances, N_query_known_instances, N_all_prot_with_known_instances, N_all_known_instances
##' @import GenomicRanges
##' @import GenomeInfoDb
##' @import data.table
##' @export benchmarkMotifs
##' @seealso \code{\link{ELMdb2GRanges}}, \code{\link{findOverlapsBench}}
benchmarkMotifs = function(occurence_file = "./SLIMFinder_Vidal/result/occurence.txt",
                           main_file = "./SLIMFinder_Vidal/result/main_result.txt",
                           domain_res = "./processed_data_files/what_we_find_VS_ELM_clust20171019.RData",
                           motif_setup = "./processed_data_files/QSLIMFinder_instances_h2v_Vidal_clust20171028.RData",
                           domain_results_obj = "res_count", motif_input_obj = "forSLIMFinder_Ready",
                           one_from_cloud = T, type = "QSLIMFinder",
                           dbfile_main = "./data_files/instances_all.gff",
                           dburl_main = "http://elm.eu.org/instances.gff?q=None&taxon=Homo%20sapiens&instance_logic=",
                           dbfile_query = "./data_files/instances_query.gff",
                           dburl_query = "http://elm.eu.org/instances.gff?q=all&taxon=irus&instance_logic=",
                           query_res_query_only = T, motif_types = c("DOC", "MOD", "LIG", "DEG", "CLV", "TRG"),
                           all_res_excl_query = T,
                           seed = 21, N = 100, replace = T, within1sequence = T,
                           predictor_col = "Sig", normalise = T,
                           minoverlap = 2, maxgap = 0, ...) {
  envir = environment()

  ### Load domain enrichment results, PPI data, and data used for QSLIMfinder
  load(domain_res, envir = envir)
  rm(list = ls()[!ls() %in% c(domain_results_obj, "envir",names(as.list(match.call())[-1]))], envir = envir)
  eval(parse(text = paste0("res_count = ", domain_results_obj)))

  load(motif_setup, envir = envir)
  rm(list = ls()[!ls() %in% c("res_count", "envir", "all_human_interaction", "all_viral_interaction", motif_input_obj, names(as.list(match.call())[-1]))], envir = envir)

  ### Load QSLIMFinder results and ELM data
  occurence = SLIMFinderOcc2GRanges(occurence_file = occurence_file,
                                    main_file = main_file,
                                    one_from_cloud = one_from_cloud)
  instances_all = ELMdb2GRanges(dbfile = dbfile_main,
                                dburl = dburl_main)
  instances_query = ELMdb2GRanges(dbfile = dbfile_query,
                                  dburl = dburl_query)

  ### Filter ELM instances located in proteins that we use to search for motifs and select motif types of interest
  searched_all = GRangesINinteractionSubsetFASTA(grange = instances_all, interactionSubsetFASTA = forSLIMFinder_Ready)
  instances_all = instances_all[searched_all$granges_in_sequences_Searched]
  instances_all = filterBYmotifType(instances_all, motif_types = motif_types)
  seqlevels(instances_all) <- seqlevelsInUse(instances_all)
  seqlengths(instances_all) = searched_all$seqlengths[names(seqlengths(instances_all))]


  searched_query = GRangesINinteractionSubsetFASTA(grange = instances_query, interactionSubsetFASTA = forSLIMFinder_Ready, query_only = query_res_query_only)
  instances_query = instances_query[searched_query$granges_in_sequences_Searched]
  instances_query = filterBYmotifType(instances_query, motif_types = motif_types)
  seqlevels(instances_query) <- seqlevelsInUse(instances_query)
  seqlengths(instances_query) = searched_query$seqlengths[names(seqlengths(instances_query))]

  if(all_res_excl_query){
    instances_all = subsetByOverlaps(instances_all, instances_query, type = "equal", invert = T)
  } else instances_all = c(instances_all, subsetByOverlaps(instances_query, instances_all, type = "equal", invert = T))

  ######################### Negative set: ranges in random locations ######################### START
  ### Generate random negative sets
  set.seed(seed)
  random_instances_all = randomGRanges(instances_all, N = N, replace = replace, within1sequence = within1sequence)
  random_instances_query = randomGRanges(instances_query, N = N, replace = replace, within1sequence = within1sequence)

  ### Combine positive and negative datasets
  combined_instances_all = lapply(random_instances_all, function(random_instance, instances_all){
    c(instances_all, random_instance)
  },instances_all)
  combined_instances_query = lapply(random_instances_query, function(random_instance, instances_query){
    c(instances_query, random_instance)
  },instances_query)

  ### Find overlaps with predicted motifs
  # All
  suppressWarnings({
    predictions_all = lapply(combined_instances_all, function(inst){
      findOverlapsBench(occuring = occurence, benchmarking = inst, predictor_col = predictor_col,
                        labels_col = "for_benchmarking", normalise = normalise, maxgap = maxgap, minoverlap = minoverlap, ...)$for_ROC$predictions
    })
    labels_all = lapply(combined_instances_all, function(inst){
      findOverlapsBench(occuring = occurence, benchmarking = inst, predictor_col = predictor_col,
                        labels_col = "for_benchmarking", normalise = normalise, maxgap = maxgap, minoverlap = minoverlap, ...)$for_ROC$labels
    })
  })
  # Query
  suppressWarnings({
    predictions_query = lapply(combined_instances_query, function(inst){
      findOverlapsBench(occuring = occurence, benchmarking = inst, predictor_col = predictor_col,
                        labels_col = "for_benchmarking", normalise = normalise, maxgap = maxgap, minoverlap = minoverlap, ...)$for_ROC$predictions
    })
    labels_query = lapply(combined_instances_query, function(inst){
      findOverlapsBench(occuring = occurence, benchmarking = inst, predictor_col = predictor_col,
                        labels_col = "for_benchmarking", normalise = normalise, maxgap = maxgap, minoverlap = minoverlap, ...)$for_ROC$labels
    })
  })
  ######################### Negative set: ranges in random locations #########################  END

  ######################### Negative set: protein in ELM, motif not in ELM  ######################### START
  ######################### Negative set: protein in ELM, motif not in ELM  ######################### END

  ######################### Negative set: protein not in ELM or protein in ELM but motif not in ELM  ######################### START
  ######################### Negative set: protein not in ELM or protein in ELM but motif not in ELM  ######################### END

  ### Get  overlapping instances
  suppressWarnings({
    overlapping_GRanges_all = findOverlapsBench(occuring = occurence, benchmarking = combined_instances_all[[1]], predictor_col = predictor_col,
                                                labels_col = "for_benchmarking", normalise = normalise, maxgap = maxgap, minoverlap = minoverlap)$overlapping_GRanges
    overlapping_GRanges_all = overlapping_GRanges_all[overlapping_GRanges_all$for_benchmarking == 1,]
    overlapping_GRanges_query = findOverlapsBench(occuring = occurence, benchmarking = combined_instances_query[[1]], predictor_col = predictor_col,
                                                  labels_col = "for_benchmarking", normalise = normalise, maxgap = maxgap, minoverlap = minoverlap)$overlapping_GRanges
    overlapping_GRanges_query = overlapping_GRanges_query[overlapping_GRanges_query$for_benchmarking == 1,]
  })

  ##### KNOWN #####
  motif_protein_table_queryKNOWN = as.data.table(cbind(mcols(instances_query)[, c("ID")], UNIPROT = seqnames(instances_query)))
  # number of proteins with motif
  N_query_prot_with_known_instances = length(unique(as.character(seqnames(instances_query)))) #motif_protein_table_queryKNOWN[, uniqueN(UNIPROT)]#, by = .(ID)]
  # total number of instances
  N_query_known_instances = length(unique(instances_query))

  motif_protein_table_allKNOWN = as.data.table(cbind(mcols(instances_all)[, c("ID")], UNIPROT = seqnames(instances_all)))
  # number of proteins with motif
  N_all_prot_with_known_instances = length(unique(as.character(seqnames(instances_all)))) #motif_protein_table_allKNOWN[, uniqueN(UNIPROT)]#, by = .(ID)]
  # total number of instances
  N_all_known_instances = length(unique(instances_all))

  ##### FOUND #####
  motif_protein_table_query = as.data.table(cbind(mcols(overlapping_GRanges_query)[, c("ID", "Pattern")], UNIPROT = seqnames(overlapping_GRanges_query)))
  # number of proteins with motif
  N_query_prot_with_known_instances_found = length(unique(as.character(seqnames(overlapping_GRanges_query)))) #motif_protein_table_query[, uniqueN(UNIPROT), by = .(ID, Pattern)]
  # total number of instances
  N_query_known_instances_found = length(unique(overlapping_GRanges_query))

  motif_protein_table_all = as.data.table(cbind(mcols(overlapping_GRanges_all)[, c("ID", "Pattern")], UNIPROT = seqnames(overlapping_GRanges_all)))
  # number of proteins with motif
  N_all_prot_with_known_instances_found = length(unique(as.character(seqnames(overlapping_GRanges_all)))) #motif_protein_table_all[, uniqueN(UNIPROT), by = .(ID, Pattern)]
  # total number of instances
  N_all_known_instances_found = length(unique(overlapping_GRanges_all))



  out = list(
    occurence = occurence,
    instances_all = instances_all, instances_query = instances_query,
    predictions_all = predictions_all, labels_all = labels_all,
    predictions_query = predictions_query, labels_query = labels_query,
    overlapping_GRanges_all = overlapping_GRanges_all,
    overlapping_GRanges_query = overlapping_GRanges_query,
    N_query_prot_with_known_instances = N_query_prot_with_known_instances, N_query_known_instances = N_query_known_instances,
    N_all_prot_with_known_instances = N_all_prot_with_known_instances, N_all_known_instances = N_all_known_instances,
    N_query_prot_with_known_instances_found = N_query_prot_with_known_instances_found, N_query_known_instances_found = N_query_known_instances_found,
    N_all_prot_with_known_instances_found = N_all_prot_with_known_instances_found, N_all_known_instances_found = N_all_known_instances_found
  )
  class(out) = "benchmarkMotifsResult"
  out
}

##' Benchmark linear motif instance found using QSLIMFinder (SLIMFinder)
##' @rdname benchmarkMotifs
##' @name mBenchmarkMotifs
##' @author Vitalii Kleshchevnikov
##' @param datasets character vector, names of the datasets ("Vidal" in "./SLIMFinder_Vidal/result/occurence.txt" or "" in "./SLIMFinder/result/occurence.txt")
##' @param descriptions character vector, description of the datasets (title of the ROC plot)
##' @param dir character, base directory. For example, "./" in "./SLIMFinder_Vidal/result/occurence.txt"
##' @return list of objects of class \code{benchmarkMotifsResult)
##' @import GenomicRanges
##' @import data.table
##' @export mBenchmarkMotifs
mBenchmarkMotifs = function(datasets = c("", "Vidal"),
                            descriptions = c("",""),
                            dir = "./",
                            domain_res = "./processed_data_files/what_we_find_VS_ELM_clust20171019.RData",
                            domain_results_obj = "res_count", motif_input_obj = "forSLIMFinder_Ready",
                            one_from_cloud = T, type = "QSLIMFinder",
                            dbfile_main = "./data_files/instances9606.gff",
                            dburl_main = "http://elm.eu.org/instances.gff?q=None&taxon=Homo%20sapiens&instance_logic=",
                            dbfile_query = "./data_files/instances10239.gff",
                            dburl_query = "http://elm.eu.org/instances.gff?q=all&taxon=irus&instance_logic=",
                            query_res_query_only = T, motif_types = c("DOC", "MOD", "LIG", "DEG", "CLV", "TRG"),
                            all_res_excl_query = T,
                            seed = 21, N = 100, replace = T, within1sequence = T,
                            predictor_col = "Sig", normalise = T, minoverlap = 2, maxgap = 0, motif_setup_month = "201710"){

  results = lapply(datasets, function(dataset) {

    description = descriptions[datasets == dataset]
    if(dataset != "") dataset = paste0("_", dataset)
    occurence_file = paste0(dir,"SLIMFinder", dataset, "/result/occurence.txt")
    main_file = paste0(dir,"SLIMFinder", dataset, "/result/main_result.txt")
    motif_setup = paste0(dir,"processed_data_files/QSLIMFinder_instances_h2v", dataset, "_clust",motif_setup_month,".RData")

    result = benchmarkMotifs(occurence_file = occurence_file,
                    main_file = main_file,
                    domain_res = domain_res,
                    motif_setup = motif_setup,
                    domain_results_obj = domain_results_obj, motif_input_obj = motif_input_obj,
                    one_from_cloud = one_from_cloud, type = type,
                    dbfile_main = dbfile_main,
                    dburl_main = dburl_main,
                    dbfile_query = dbfile_query,
                    dburl_query = dburl_query,
                    query_res_query_only = query_res_query_only, motif_types = motif_types,
                    all_res_excl_query = all_res_excl_query,
                    seed = seed, N = N, replace = replace, within1sequence = within1sequence,
                    predictor_col = predictor_col, normalise = normalise, minoverlap = minoverlap, maxgap = maxgap)

    result$description = description
    result
  })

  resnames = character(length(datasets))
  resnames[datasets != ""] = datasets[datasets != ""]
  resnames[datasets == ""] = "full_Intact"
  names(results) = resnames

  results
}
